(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{326:function(e,t,a){e.exports=a.p+"assets/img/image-20211201151152152.be29c24b.png"},373:function(e,t,a){e.exports=a.p+"assets/img/image-20210315163938998.b6757b29.png"},374:function(e,t,a){e.exports=a.p+"assets/img/image-20210305162547907.5c606039.png"},375:function(e,t,a){e.exports=a.p+"assets/img/image-20210622135701100.229e4fc5.png"},376:function(e,t,a){e.exports=a.p+"assets/img/image-20210622140822748.075d6e71.png"},377:function(e,t,a){e.exports=a.p+"assets/img/image-20210622145722807.a4c67a66.png"},378:function(e,t,a){e.exports=a.p+"assets/img/image-20210622164108577.32f36e5a.png"},379:function(e,t,a){e.exports=a.p+"assets/img/image-20210622170037603.407ac1c7.png"},380:function(e,t,a){e.exports=a.p+"assets/img/image-20210622170400754.f0a82b30.png"},381:function(e,t,a){e.exports=a.p+"assets/img/image-20210623110232447.12087678.png"},382:function(e,t,a){e.exports=a.p+"assets/img/image-20210623143801475.a45243e6.png"},383:function(e,t,a){e.exports=a.p+"assets/img/image-20210623144032852.9165a96b.png"},384:function(e,t,a){e.exports=a.p+"assets/img/image-20210623154302967.0930ff80.png"},385:function(e,t,a){e.exports=a.p+"assets/img/image-20210623170103743.1cffa719.png"},386:function(e,t,a){e.exports=a.p+"assets/img/image-20211201145921921.187590a3.png"},400:function(e,t,a){"use strict";a.r(t);var r=a(42),o=Object(r.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"探索下react的渲染过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#探索下react的渲染过程"}},[e._v("#")]),e._v(" 探索下react的渲染过程")]),e._v(" "),r("h2",{attrs:{id:"序言"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#序言"}},[e._v("#")]),e._v(" 序言")]),e._v(" "),r("p",[e._v("一直以来，对于react渲染过程的了解都是知其然不知其所以然，虽然在网上看了不少资料，但是总是看过就忘。这次就借着梳理的机会，一步步的走下react的渲染过程。")]),e._v(" "),r("p",[e._v('我所使用的版本为"react": "16.8.6", "react-dom": "16.8.6"。')]),e._v(" "),r("h2",{attrs:{id:"开始"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#开始"}},[e._v("#")]),e._v(" 开始")]),e._v(" "),r("p",[e._v("我目前看的教程，里面将react的渲染过程分为了三个阶段：legacyRenderSubtreeIntoContainer开始，直到scheduleUpdateOnFiber为初始化阶段，scheduleUpdateOnFiber到commitRoot为render阶段，commitRoot以后为commit阶段。个人觉得还是很有道理，所以我也就按照这个思路来进行梳理。")]),e._v(" "),r("h3",{attrs:{id:"初始化阶段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#初始化阶段"}},[e._v("#")]),e._v(" 初始化阶段")]),e._v(" "),r("p",[r("img",{attrs:{src:a(373),alt:"image-20210315163938998"}})]),e._v(" "),r("p",[e._v("通过查看调用栈，我们进入到了一个非常熟悉的函数，render函数")]),e._v(" "),r("h4",{attrs:{id:"render函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#render函数"}},[e._v("#")]),e._v(" render函数")]),e._v(" "),r("p",[r("img",{attrs:{src:a(374),alt:"image-20210305162547907"}})]),e._v(" "),r("p",[e._v("render位于react-dom包内，在render函数里，去除一些对于组件和dom的判断，实际仅仅是调用了一个函数"),r("code",[e._v("legacyRenderSubtreeIntoContainer")]),e._v("。这个函数的参数如下"),r("img",{attrs:{src:a(375),alt:"image-20210622135701100"}})]),e._v(" "),r("p",[e._v("可以看到render的入参，"),r("code",[e._v("element")]),e._v("、"),r("code",[e._v("container")]),e._v("和"),r("code",[e._v("callback")]),e._v("透传给了"),r("code",[e._v("legacyRenderSubtreeIntoContainer")]),e._v("，分别作为"),r("code",[e._v("children")]),e._v("，"),r("code",[e._v("container")]),e._v("和"),r("code",[e._v("callback")]),e._v("。")]),e._v(" "),r("p",[r("img",{attrs:{src:a(376),alt:"image-20210622140822748"}})]),e._v(" "),r("p",[e._v("那么这里的element和container是什么呢？我们通过断点可以发现，"),r("strong",[r("code",[e._v("container")]),e._v("是id为root的div")]),e._v("，"),r("strong",[r("code",[e._v("element")]),e._v("则是我们代码里调用的"),r("code",[e._v("ReactDOM.render")]),e._v("里的第一个子元素"),r("code",[e._v("React.StrictMode")])]),e._v("。即container就是我们的容器，element则是我们的第一个元素。")]),e._v(" "),r("h4",{attrs:{id:"legacyrendersubtreeintocontainer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#legacyrendersubtreeintocontainer"}},[e._v("#")]),e._v(" legacyRenderSubtreeIntoContainer")]),e._v(" "),r("p",[r("img",{attrs:{src:a(377),alt:"image-20210622145722807"}})]),e._v(" "),r("p",[e._v("上面的代码主要目的是为了创建fiberRoot对象，并且在接下来使用fiberRoot对象。那么这个对象究竟是什么呢？我们得先来到root的创建地点，"),r("code",[e._v("legacyCreateRootFromDOMContainer")]),e._v("函数中")]),e._v(" "),r("h4",{attrs:{id:"legacycreaterootfromdomcontainer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#legacycreaterootfromdomcontainer"}},[e._v("#")]),e._v(" legacyCreateRootFromDOMContainer")]),e._v(" "),r("p",[r("img",{attrs:{src:a(378),alt:"image-20210622164108577"}})]),e._v(" "),r("p",[e._v("#####legacyCreateRootFromDOMContainer的内容")]),e._v(" "),r("p",[e._v("这个函数很有意思，函数名翻译过来是通过dom容器来创建根节点，但是整体内容做的是删除的事。他通过参数"),r("code",[e._v("forceHydrate")]),e._v("和函数"),r("code",[e._v("shouldHydrateDueToLegacyHeuristic")]),e._v("来判断是否需要合并，如果不需要合并，则删除当前容器下的子节点。然后调用"),r("code",[e._v("createLegacyRoot")]),e._v("继续创建root。")]),e._v(" "),r("p",[e._v("我们知道，在前面调用的时候，"),r("code",[e._v("forceHydrate")]),e._v("已经被赋值为了false，所以判断是否需要合并只剩下一个未知条件，即"),r("code",[e._v("shouldHydrateDueToLegacyHeuristic")]),e._v("函数。")]),e._v(" "),r("h5",{attrs:{id:"shouldhydrateduetolegacyheuristic"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#shouldhydrateduetolegacyheuristic"}},[e._v("#")]),e._v(" shouldHydrateDueToLegacyHeuristic")]),e._v(" "),r("p",[e._v("代码第一行，就调用了这个函数来作为一个条件的赋值，我们先来看看这个函数是做什么的。")]),e._v(" "),r("p",[e._v("这个函数实际上是为了判断需不需要合并子节点元素。")]),e._v(" "),r("p",[r("img",{attrs:{src:a(379),alt:"image-20210622170037603"}})]),e._v(" "),r("p",[r("img",{attrs:{src:a(380),alt:"image-20210622170400754"}})]),e._v(" "),r("p",[e._v("这个函数在容器不存在时，返回false。在容器为文档节点时，由于nodeType不是ELEMENT_NODE，也返回false。在容器为普通元素时，如果容器没有子元素，返回false；如果容器有子元素节点时，判断是否有属性"),r("code",[e._v("data-reactroot")]),e._v("，没有返回false。"),r("strong",[e._v("也就是说，只有子元素节点含有属性"),r("code",[e._v("data-reactroot")]),e._v("这一种情况，才需要合并")]),e._v("。")]),e._v(" "),r("p",[e._v("在本项目中，由于没有子元素节点，直接返回false")]),e._v(" "),r("h4",{attrs:{id:"root对象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#root对象"}},[e._v("#")]),e._v(" root对象")]),e._v(" "),r("p",[r("img",{attrs:{src:a(381),alt:"image-20210623110232447"}})]),e._v(" "),r("p",[e._v("接下来，经过层层调用，最终进入到了这个函数内，这里我们总算见到我们苦苦追寻的对象root。在createLegacyRoot函数中，"),r("strong",[e._v("使用了"),r("code",[e._v("new ReactDOMBlockingRoot")]),e._v("，创建了root对象")]),e._v("。同时，在构造函数中，我们也发现了fiberRoot的由来。")]),e._v(" "),r("h4",{attrs:{id:"fiberroot对象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiberroot对象"}},[e._v("#")]),e._v(" fiberRoot对象")]),e._v(" "),r("img",{staticStyle:{zoom:"50%"},attrs:{src:a(382),alt:"image-20210623143801475"}}),e._v(" "),r("p",[e._v("在往下探寻，可以发现，fiberRoot对象是通过"),r("code",[e._v("new FiberRootNode")]),e._v("生成的。同时，给fiberRoot赋值了一个current属性，那么这个current属性是什么？")]),e._v(" "),r("img",{staticStyle:{zoom:"50%"},attrs:{src:a(383),alt:"image-20210623144032852"}}),e._v(" "),r("p",[e._v("我们可以看到，"),r("strong",[e._v("fiberRoot对象的current就是一个FiberNode对象")])]),e._v(" "),r("p",[e._v("**现在我们可以梳理一下目前所创建的对象之间的关系，首先，是我们的dom容器container，container上有一个_reactRootContainer属性，是我们的root（ReactDOMBlockingRoot）对象，root对象上有一个_internalRoot属性，是fiberRoot（FiberRootNode）对象，而在fiberRoot上有current属性，是一个rootFiber（FiberNode）对象。**如下图所示：")]),e._v(" "),r("img",{staticStyle:{zoom:"40%"},attrs:{src:a(384),alt:"image-20210623154302967"}}),e._v(" "),r("p",[e._v("这样，我们就串联起了**dom节点和fiber根节点rootFiber。**既然dom树和fiber树之间有了联系，那我们接下来就应该先把fiber树整出来。")]),e._v(" "),r("h4",{attrs:{id:"unbatchedupdates"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#unbatchedupdates"}},[e._v("#")]),e._v(" unbatchedUpdates")]),e._v(" "),r("p",[e._v("回到最初的起点legacyRenderSubtreeIntoContainer，在创建完fiberRoot之后，我们应该要执行unbatchedUpdates这个方法")]),e._v(" "),r("img",{staticStyle:{zoom:"50%"},attrs:{src:a(385),alt:"image-20210623170103743"}}),e._v(" "),r("p",[e._v("这里，我们先不关注对于上下文和回调队列的处理，可以看到，重点是执行了fn这个函数，而这里的fn，就是前面被包装了一层的updateContainer方法")]),e._v(" "),r("h4",{attrs:{id:"updatecontainer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#updatecontainer"}},[e._v("#")]),e._v(" updateContainer")]),e._v(" "),r("img",{staticStyle:{zoom:"50%"},attrs:{src:a(386),alt:"image-20211201145921921"}}),e._v(" "),r("p",[e._v("updateContainer主要救赎做了三件事")]),e._v(" "),r("ul",[r("li",[e._v("获取优先级lane")]),e._v(" "),r("li",[e._v("创建update对象，并放入队列")]),e._v(" "),r("li",[e._v("调度当前节点")])]),e._v(" "),r("h4",{attrs:{id:"scheduleupdateonfiber"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#scheduleupdateonfiber"}},[e._v("#")]),e._v(" scheduleUpdateOnFiber")]),e._v(" "),r("img",{staticStyle:{zoom:"50%"},attrs:{src:a(326),alt:"image-20211201151152152"}}),e._v(" "),r("img",{staticStyle:{zoom:"50%"},attrs:{src:a(326),alt:"image-20211201151152152"}}),e._v(" "),r("p",[e._v("在scheduleUpdateOnFiber中，经过了一系列的校验，检查后，因为我们首次渲染，所以我们会进入到同步渲染中，即performSyncWorkOnRoot。同时，这也标志我们的准备工作做的差不多了，即将"),r("strong",[e._v("进入render阶段")])]),e._v(" "),r("blockquote",[r("p",[e._v("这里之所以使同步，还因为我们的入口使用的是legacy 模式，即ReactDOM.render("),r("App"),e._v(", rootNode)。这是当前 React App 使用的方式，当前没有计划删除本模式，但是这个模式可能不支持这些新功能。")],1)]),e._v(" "),r("p",[r("img",{attrs:{src:"https://gitee.com/nocry/img-bed/raw/master/img/image-20211202134803381.png",alt:"image-20211202134803381"}})])])}),[],!1,null,null,null);t.default=o.exports}}]);